# Common constants and functions shared by the install related scripts.

## constants ##

# log threshold values
LOG_DEBUG=0
LOG_INFO=1    # default for --verbose
LOG_SUMMARY=2 # default
LOG_REPORT=3  # suppress all output, other than final reporting
LOG_QUIET=9   # value for --quiet = suppress all output
LOG_FORCE=99  # force write regardless of VERBOSE setting

## functions ##

# display: append the passed-in message to localhost's logfile, and potentially
# write the message to stdout, depending on the value of the passed-in priority
# setting. A timestamp is prepending (only) to the logfile msg.
# NOTE: $LOGFILE should be defined if logging is desired.
# NOTE: $VERBOSE should be defined if "threshold" echos are desired.
#   $1=msg,
#   $2=msg prioriy, optional, default=$LOG_SUMMARY,
#   $3=logfile,     optional, default=$LOGFILE which can be empty.
#
function display(){

  local pri=${2:-$LOG_SUMMARY}
  local log=${3:-$LOGFILE}
  local verbose=${VERBOSE:-$LOG_DEBUG}

  [[ -n "$log" ]] && echo "[$(date +%T)] $1" >> $log
  (( pri >= verbose )) && echo -e "$1"
}

# fixup_etc_host_file: append all ips + hostnames to /etc/hosts, unless the
# ip address already exists. Expects HOSTS(), HOST_IPS() and NUMNODES global
# variables to be set.
# NOTE: only call if local hosts file contains ip addresses, ie not using dns.
#
function fixup_etc_hosts_file(){

  local host=; local ip=; local hosts_buf=''; local i
  local tmp_etchosts="$(mktemp)"

  # create tmp file containing all non-blank, non-comment records in the
  # /etc/hosts file
  sed '/^ *#/d;/^ *$/d;s/#.*//' /etc/hosts >$tmp_etchosts

  for (( i=0; i<$NUMNODES; i++ )); do
        host="${HOSTS[$i]}"; ip="${HOST_IPS[$i]}"
        # skip if host and/or ip already present in /etc/hosts
        grep -qs "$ip" $tmp_etchosts && continue # skip to next node
        hosts_buf+="$ip $host # auto-generated by RHS install"$'\n' # \n at end
  done
  if (( ${#hosts_buf} > 2 )) ; then
    hosts_buf=${hosts_buf:0:${#hosts_buf}-1} # remove \n for last host entry
    display "   appending: \"$hosts_buf\" to /etc/hosts" $LOG_DEBUG
    echo "$hosts_buf" >>/etc/hosts
  fi
}

# match_dir: given the passed-in filename ($1) set the global variables
# MATCH_DIR and MATCH_FILE to the dirname and basename if $1 matches one of
# the entries in SUBDIR_FILES.
# Args:
#   $1=filename to be matched (can be wildcarded as a regexp, not glob)
#   $2=list of paths formatted as "dir/file dir/f dir/dir/f ..."
#
function match_dir(){

  local match="$1"; local paths="$2"
  local f; local dir

  MATCH_DIR=''; MATCH_FILE=''
  [[ -z "$paths" ]] && return # nothing to do...

  for f in $paths; do
      dir="$(dirname $f)"; f="$(basename $f)"
      [[ "$f" =~ "$match" ]] && {
        $MATCH_DIR="$dir"; $MATCH_FILE="$f"; return; }
  done
}

# verify_local_deploy_setup: make sure that the expected deploy files are in
# place. Collect all detected setup errors together (rather than one at a time)
# for better usability. Validate format and size of hosts file. Verify
# connectivity between localhost and each data/storage node. Assign global
# HOSTS, HOST_IPS, and MGMT_NODE variables.
#
# Args:
#   $1=false means to skip various checks that are needed by install.sh but are
#      not needed by passwordless-ssh. Default is true.
#
function verify_local_deploy_setup(){

  local verify_arg=${1:-true} # default is full checking
  local errmsg=''; local errcnt=0

  # read_verify_local_hosts_file: sub-function to read the deploy "hosts"
  # file, split it into the HOSTS, optionally, HOST_IPS, and optionally BRICKS
  # global array variables, validate hostnames and ips (if present), and verify
  # password-less ssh connectivity to each node.  Hosts file format:
  #    [ip-addr] FQDN-or-hostname [brick-device-path]
  #    ...
  #
  # If the ip address field is missing in the first record it must be absent
  # for every record in the hosts file, and conversely, if the ip is present in
  # the first record it must also appear in all records. Likewise, if a brick-
  # device path is present in the first record it must appear in all records.
  # NOTE: lack of the ip address field implies that DNS is being used.
  #
  # Comments and empty lines are ignored in the hosts file. The number of nodes
  # represented in the hosts file is enforced to be a multiple of the replica
  # count. Downcase host names if they are upper case.
  # Expects the following global variables to already be set:
  #   HOSTS_FILE  -- name of local hosts file. Can be set by --hosts option
  #                  otherwise expected to be $PWD/hosts.
  #   MGMT_NODE   -- name of management node, if supplied.
  #   LOG_DEBUG   -- verbose setting.
  #   LOG_FORCE   -- verbose setting.
  #
  # Sets the folowing global variables:
  #   HOSTS()
  #   HOST_IPS()
  #   BRICKS()
  #   USING_DNS, true or false, depending on content of local ./hosts file
  #   NUMNODES
  #   MGMT_NODE
  #   MGMT_NODE_IN_POOL
  # 
  function read_verify_local_hosts_file(){

    local i; local host=; local ip=; local ssh_target; local out
    local hosts_ary; local numTokens
    local numLines; local lineNum; local tokensPerLine
    local brick; local have_bricks
    local tmphosts="$(mktemp)"

    # regular expression to validate ip addresses
    local VALID_IP_RE='^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$'

    # regular expression to validate hostnames (host is down-cased)
    local VALID_HOSTNAME_RE='^(([a-z0-9]|[a-z0-9][a-z0-9\-]*[a-z0-9])\.)*([a-z0-9]|[a-z0-9][a-z0-9\-]*[a-z0-9])$'

    # create tmp file containing all non-blank, non-comment records in the
    # local hosts file
    sed '/^ *#/d;/^ *$/d;s/#.*//' $HOSTS_FILE >$tmphosts
    numLines=$(wc -l <$tmphosts)

    # read the tmp hosts file into an array
    read -a hosts_ary <<< $(cat $tmphosts)
    HOSTS=(); HOST_IPS=(); BRICKS=() # global vars
    numTokens=${#hosts_ary[@]}
    tokensPerLine=$((numTokens/numLines))

    case $tokensPerLine in
      1) # hostname only
	USING_DNS=true; have_bricks=false
      ;;
      2) # ip+host or host+brick
	if [[ "${hosts_ary[0]}" =~ $VALID_IP_RE ]] ; then
	  USING_DNS=false; have_bricks=false
	else
	  USING_DNS=true; have_bricks=true
	fi
      ;;
      3) # ip+host+brick
	USING_DNS=false; have_bricks=true
      ;;
      *)
	errmsg+=" * Unrecognized $HOSTS_FILE format, expect: [ip] host [brick]"
	((errcnt++))
	return # no point in parsing hosts file
      ;;
    esac

    for (( i=0; i<$numTokens; i++ )); do
	ssh_target=''
	# set 1-based line/record number
        lineNum=$(( (i/tokensPerLine)+1)) # one-based

	# optional ip address:
	if [[ $USING_DNS == false ]] ; then
	  ip=${hosts_ary[$i]}
	  if [[ $ip =~ $VALID_IP_RE ]] ; then
	    ssh_target=$ip
            ((i++))
	  elif [[ "$verify_arg" == true ]] ; then
	    errmsg+=" * $HOSTS_FILE record $lineNum:\n   Unexpected IP address syntax for \"$ip\"\n"
	    ((errcnt++))
	    break # exit loop
	  fi
	fi

	# required FQDN or simple hostname:
	host=${hosts_ary[$i]}
	if [[ $USING_DNS == true ]] ; then # need to get ip
	  ip=($(getent hosts "$host")) # -> (ip-addr hostname)
	  ip=${ip[0]} # extract the ip-addr
	fi
        # down-case if any upper-case letters in host
	if [[ "$host" =~ [A-Z]+ ]] ; then
	  display "   ...down-casing $host" $LOG_DEBUG
	  host=${host,,} # down-case
	fi
	# validate basic hostname syntax
 	if [[ "$verify_arg" == true && ! $host =~ $VALID_HOSTNAME_RE ]] ; then
	  errmsg+=" * $HOSTS_FILE record $lineNum:\n   Unexpected hostname syntax for \"$host\"\n"
	  ((errcnt++))
	  break # exit loop
        fi
	# if ssh target is not already an ip then set it to host
	[[ -z "$ssh_target" ]] && ssh_target="$host"
        # set MGMT_NODE to first node unless --mgmt-node specified
	if [[ -z "$MGMT_NODE" && $lineNum == 1 ]] ; then
	  MGMT_NODE="$host"
          MGMT_NODE_IN_POOL=true
	elif [[ -n "$MGMT_NODE" && "$MGMT_NODE" == "$host" ]] ; then
          MGMT_NODE_IN_POOL=true
        fi
	if [[ "$verify_arg" == true ]] ; then
          # verify connectivity from localhost to data node. Note: ip used since
	  # /etc/hosts may not be set up to map ip to hostname
	  ssh -q -oBatchMode=yes -oStrictHostKeyChecking=no \
		root@$ssh_target exit
          if (( $? != 0 )) ; then
	    errmsg+=" * $HOSTS_FILE record $lineNum:\n   Cannot connect via password-less ssh to \"$host\"\n"
	    ((errcnt++))
	    break # exit loop
	  fi
	fi

	# optional brick-device path:
	if [[ $have_bricks == true ]] ; then
	  ((i++))
	  brick=${hosts_ary[$i]} # extract the brick-dev
	  # verify brick exists on host
	  if [[ "$verify_arg" == true ]] ; then
	    out="$(ssh root@$host "
		  if [[ ! -e $brick ]] ; then
		    echo 'does not exist'
		  elif [[ ! -b $brick ]] ; then
		    echo 'is not a block device'
		  fi")"
	    if [[ -n "$out" ]] ; then
	      errmsg+=" * $HOSTS_FILE record $lineNum:\n   \"$brick\" $out\n"
	      ((errcnt++))
	      break # exit loop
	    fi
	  fi
	  BRICKS+=($brick)
	fi

	HOSTS+=($host)
	HOST_IPS+=($ip)
    done

    (( errcnt != 0 )) && return # errors in hosts checking loop are fatal

    NUMNODES=${#HOSTS[@]} # global var used by other functions and scripts

    if [[ -n "$REPLICA_CNT" ]] ; then
      # validate the number of nodes in the hosts file
      if [[ "$verify_arg" == true ]] && (( NUMNODES < REPLICA_CNT )) ; then
        errmsg+=" * The $HOSTS_FILE file must contain at least $REPLICA_CNT nodes (replica count)\n"
        ((errcnt++))
      elif (( NUMNODES % REPLICA_CNT != 0 )) ; then
        errmsg+=" * The number of nodes in the $HOSTS_FILE file must be a multiple of the\n   replica count ($REPLICA_CNT)\n"
        ((errcnt++))
      fi
    fi
  }

  # main #
  #      #
  if [[ ! -f $HOSTS_FILE ]] ; then
    errmsg+=" * \"$HOSTS_FILE\" file is missing.\n   This file contains a list of IP address followed by hostname, one\n   pair per line. Use \"hosts.example\" as an example.\n"
    ((errcnt++))
  else
    # read and verify/validate hosts file format
    read_verify_local_hosts_file
  fi

  if (( errcnt > 0 )) ; then
    local plural='s'
    (( errcnt == 1 )) && plural=''
    display "$errcnt error$plural:\n$errmsg" $LOG_FORCE
    exit 1
  fi
  display "   ...verified" $LOG_DEBUG
}

# pv_present: return 0(shell true) if the passed in PV exists.
#
function pv_present(){

  local pv="$1"

  pvs $pv >& /dev/null
}

# vg_present: return 0(shell true) if the passed in VG exists.
#
function vg_present(){

  local vg="$1"

  vgs $vg >& /dev/null
}

# lv_present: return 0(shell true) if the passed in LV-dev path exists.
# Note: lv is expected to passed in as /dev/VG/LV.
#
function lv_present(){

  local lvpath="$1"

  lvs $lvpath >& /dev/null
}

