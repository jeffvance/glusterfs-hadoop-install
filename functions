# Common constants and functions shared by the install related scripts.

## constants ##

# log threshold values
LOG_DEBUG=0
LOG_INFO=1    # default for --verbose
LOG_SUMMARY=2 # default
LOG_REPORT=3  # suppress all output, other than final reporting
LOG_QUIET=9   # value for --quiet = suppress all output
LOG_FORCE=99  # force write regardless of VERBOSE setting

## functions ##

# display: append the passed-in message to localhost's logfile, and potentially
# write the message to stdout, depending on the value of the passed-in priority
# setting.
# NOTE: $LOGFILE should be defined if logging is desired.
# NOTE: $VERBOSE should be defined if "threshold" echos are desired.
#   $1=msg,
#   $2=msg prioriy, optional, default=$LOG_SUMMARY,
#   $3=logfile,     optional, default=$LOGFILE which can be empty.
#
function display(){

  local pri=${2:-$LOG_SUMMARY}
  local log=${3:-$LOGFILE}
  local verbose=${VERBOSE:-$LOG_DEBUG}

  [[ -n "$log" ]] && echo "$1" >> $log
  (( pri >= verbose )) && echo -e "$1"
}

# fixup_etc_host_file: append all ips + hostnames to /etc/hosts, unless the
# hostnames already exist.
#
function fixup_etc_hosts_file(){

  local host=; local ip=; local hosts_buf=''; local i

  for (( i=0; i<$NUMNODES; i++ )); do
        host="${HOSTS[$i]}"
        ip="${HOST_IPS[$i]}"
        # skip if host already present in /etc/hosts
        grep -qs "$host" /etc/hosts && continue # skip to next node
        hosts_buf+="$ip $host # auto-generated by RHS install"$'\n' # \n at end
  done
  if (( ${#hosts_buf} > 2 )) ; then
    hosts_buf=${hosts_buf:0:${#hosts_buf}-1} # remove \n for last host entry
    display "   appending: \"$hosts_buf\" to /etc/hosts" $LOG_DEBUG
    echo "$hosts_buf" >>/etc/hosts
  fi
}

# match_dir: given the passed-in filename ($1) set the global variables
# MATCH_DIR and MATCH_FILE to the dirname and basename if $1 matches one of
# the entries in SUBDIR_FILES.
# Args:
#   $1=filename to be matched (can be wildcarded as a regexp, not glob)
#   $2=list of paths formatted as "dir/file dir/f dir/dir/f ..."
#
function match_dir(){

  local match="$1"; local paths="$2"
  local f; local dir

  MATCH_DIR=''; MATCH_FILE=''
  [[ -z "$paths" ]] && return # nothing to do...

  for f in $paths; do
      dir="$(dirname $f)"; f="$(basename $f)"
      [[ "$f" =~ "$match" ]] && {
        $MATCH_DIR="$dir"; $MATCH_FILE="$f"; return; }
  done
}

# verify_local_deploy_setup: make sure that the expected deploy files are in
# place. Collect all detected setup errors together (rather than one at a time)
# for better usability. Validate format and size of hosts file. Verify
# connectivity between localhost and each data/storage node. Assign global
# HOSTS, HOST_IPS, and MGMT_NODE variables.
#
# Args:
#   $1=false means to skip various checks that are needed by install.sh but are
#      not needed by passwordless-ssh. Default is true.
#
function verify_local_deploy_setup(){

  local errmsg=''; local errcnt=0
  local verify_arg=${1:-true} # default is full checking

  # read_verify_local_hosts_file: sub-function to read the deploy "hosts"
  # file, split it into the HOSTS and, optionally, HOST_IPS global array
  # variables, validate hostnames and ips (if present), and verify password-
  # less ssh connectivity to each node. If the ip address field is missing it
  # must be absent for every record in the file, and conversely, if the ip is
  # present it must appear at the beginning of every record. NOTE: lack of the
  # ip address field implies that DNS is being used.
  # Comments and empty lines are ignored in the hosts file. The number of nodes
  # represented in the hosts file is enforced to be a multiple of the replica
  # count. Downcase host names if they are upper case.
  # Expects the following global variables to already be set:
  #   HOSTS_FILE  -- name of local hosts file. Can be set by --hosts option
  #                  otherwise expected to be $PWD/hosts.
  #   MGMT_NODE   -- name of management node, if supplied
  #
  # Sets the folowing global variables:
  #   HOSTS()
  #   HOST_IPS()
  #   USING_DNS, true or false, depending on content of local ./hosts file
  #   NUMNODES
  #   MGMT_NODE
  #   MGMT_NODE_IN_POOL
  # 
  function read_verify_local_hosts_file(){

    local i; local host=; local ip=; local ssh_target
    local hosts_ary; local numTokens
    local numLines; local lineNum
    local tmphosts="$(mktemp)"

    # regular expression to validate ip addresses
    local VALID_IP_RE='^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$'

    # regular expression to validate hostnames (host is down-cased)
    local VALID_HOSTNAME_RE='^(([a-z0-9]|[a-z0-9][a-z0-9\-]*[a-z0-9])\.)*([a-z0-9]|[a-z0-9][a-z0-9\-]*[a-z0-9])$'

    # create tmp file containing all non-blank, non-comment records in the
    # local hosts file
    sed '/^ *#/d;/^ *$/d;s/#.*//' $HOSTS_FILE >$tmphosts
    numLines=$(wc -l <$tmphosts)

    # read the tmp hosts file into an array
    read -a hosts_ary <<< $(cat $tmphosts)
    HOSTS=(); HOST_IPS=() # global vars
    numTokens=${#hosts_ary[@]}

    # do we expect to have the ip column or not?
    (( numLines == numTokens )) && USING_DNS=true || USING_DNS=false
echo "**** numLines=$numLines, USING_DNS=$USING_DNS, numTok=$numTokens"
echo "**** hosts_ary=${hosts_ary[@]}"

    # hosts file format: ip-address  hostname  # one pair per line
    for (( i=0; i<$numTokens; i++ )); do
	ssh_target=''
	# set 1-based line/record number
	[[ $USING_DNS == true ]] && lineNum=$((i+1)) || lineNum=$(((i/2)+1))
echo "**** lineNum=$lineNum", i=$i

	# see if this field is an ip address
	if [[ $USING_DNS == false ]] ; then
	  ip=${hosts_ary[$i]}
echo "***** ip=$ip"
	  if [[ $ip =~ $VALID_IP_RE ]] ; then
	    ssh_target=$ip
            ((i++))
	  elif [[ "$verify_arg" == true ]] ; then
	    errmsg+=" * $HOSTS_FILE record $lineNum:\n   Unexpected IP address syntax for \"$ip\"\n"
	    ((errcnt++))
	    break # exit loop
	  fi
	fi

	# hostname:
	host=${hosts_ary[$i]}
	if [[ $USING_DNS == true ]] ; then # need to get ip
	  ip=($(getent hosts "$host")) # -> (ip-addr hostname)
	  ip=${ip[0]} # extract the ip-addr
	fi
echo "***** host=$host, ip=$ip"
        # down-case if any upper-case letters in host
	if [[ "$host" =~ [A-Z]+ ]] ; then
	  display "   ...down-casing $host" $LOG_DEBUG
	  host=${host,,} # down-case
	fi
	# validate basic hostname syntax
 	if [[ "$verify_arg" == true && ! $host =~ $VALID_HOSTNAME_RE ]] ; then
	  errmsg+=" * $HOSTS_FILE record $lineNum:\n   Unexpected hostname syntax for \"$host\"\n"
	  ((errcnt++))
	  break # exit loop
        fi
	# set ssh target not already an ip then set it to host
	[[ -z "$ssh_target" ]] && ssh_target="$host"
        # set MGMT_NODE to first node unless --mgmt-node specified
	if [[ -z "$MGMT_NODE" && $lineNum == 1 ]] ; then
	  MGMT_NODE="$host"
          MGMT_NODE_IN_POOL=true
	elif [[ -n "$MGMT_NODE" && "$MGMT_NODE" == "$host" ]] ; then
          MGMT_NODE_IN_POOL=true
        fi

	if [[ "$verify_arg" == true ]] ; then
          # verify connectivity from localhost to data node. Note: ip used since
	  # /etc/hosts may not be set up to map ip to hostname
	  ssh -q -oBatchMode=yes -oStrictHostKeyChecking=no \
		root@$ssh_target exit
          if (( $? != 0 )) ; then
	    errmsg+=" * $HOSTS_FILE record $lineNum:\n   Cannot connect via password-less ssh to \"$host\"\n"
	    ((errcnt++))
	    break # exit loop
	  fi
	fi
	HOSTS+=($host)
	HOST_IPS+=($ip)
    done

    (( errcnt != 0 )) && return # errors in hosts checking loop are fatal

    NUMNODES=${#HOSTS[@]} # global var used by other functions and scripts

    if [[ -n "$REPLICA_CNT" ]] ; then
      # validate the number of nodes in the hosts file
      if [[ "$verify_arg" == true ]] && (( NUMNODES < REPLICA_CNT )) ; then
        errmsg+=" * The $HOSTS_FILE file must contain at least $REPLICA_CNT nodes (replica count)\n"
        ((errcnt++))
      elif (( NUMNODES % REPLICA_CNT != 0 )) ; then
        errmsg+=" * The number of nodes in the $HOSTS_FILE file must be a multiple of the\n   replica count ($REPLICA_CNT)\n"
        ((errcnt++))
      fi
    fi
  }

  # main #
  #      #
  if [[ ! -f $HOSTS_FILE ]] ; then
    errmsg+=" * \"$HOSTS_FILE\" file is missing.\n   This file contains a list of IP address followed by hostname, one\n   pair per line. Use \"hosts.example\" as an example.\n"
    ((errcnt++))
  else
    # read and verify/validate hosts file format
    read_verify_local_hosts_file
  fi

  if (( errcnt > 0 )) ; then
    local plural='s'
    (( errcnt == 1 )) && plural=''
    display "$errcnt error$plural:\n$errmsg" $LOG_FORCE
    exit 1
  fi
  display "   ...verified" $LOG_DEBUG
echo "********* HOSTS=${HOSTS[@]}"
echo "********* IPs=${HOST_IPS[@]}"
}

